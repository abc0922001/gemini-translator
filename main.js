#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const axios = require('axios');
const yargs = require('yargs');
const { PromisePool } = require('@supercharge/promise-pool');

// Mistral AI ÈÖçÁΩÆ
const MISTRAL_API_URL = 'https://api.mistral.ai/v1/chat/completions';
const MISTRAL_MODEL = 'mistral-small-latest';

// ÊîØÊè¥ÁöÑÊ™îÊ°àÊ†ºÂºè
const SUPPORTED_EXTENSIONS = ['.srt', '.vtt', '.ass', '.md'];

// ÂëΩ‰ª§ÂàóÂèÉÊï∏Ë®≠ÂÆö
const argv = yargs
  .option('input', {
    alias: 'i',
    describe: 'Ëº∏ÂÖ•Â≠óÂπïÊ™îÊ°àË∑ØÂæë (SRT/WebVTT/ASS/Markdown)',
    type: 'string',
    demandOption: true
  })
  .option('output', {
    alias: 'o',
    describe: 'Ëº∏Âá∫Â≠óÂπïÊ™îÊ°àË∑ØÂæë',
    type: 'string'
  })
  .option('model', {
    alias: 'm',
    describe: 'Mistral Ê®°ÂûãÂêçÁ®±',
    type: 'string',
    default: MISTRAL_MODEL
  })
  .option('autofix', {
    describe: 'Ëá™Âãï‰øÆÂæ©Â≠óÂπïÁ∑®Ëôü',
    type: 'boolean',
    default: false
  })
  .option('concurrency', {
    alias: 'c',
    describe: '‰∏¶ÁôºËôïÁêÜÊï∏Èáè',
    type: 'number',
    default: 5
  })
  .option('batch-size', {
    alias: 'b',
    describe: 'ÊâπÊ¨°ËôïÁêÜÂ§ßÂ∞è',
    type: 'number',
    default: 10
  })
  .option('from-lang', {
    alias: 'f',
    describe: '‰æÜÊ∫êË™ûË®Ä (È†êË®≠: Ëã±Êñá)',
    type: 'string',
    default: 'English'
  })
  .option('to-lang', {
    alias: 't',
    describe: 'ÁõÆÊ®ôË™ûË®Ä (È†êË®≠: ÁπÅÈ´î‰∏≠Êñá)',
    type: 'string',
    default: 'ÁπÅÈ´î‰∏≠Êñá'
  })
  .option('style', {
    alias: 's',
    describe: 'ÁøªË≠ØÈ¢®Ê†º (formal/casual/technical)',
    type: 'string',
    default: 'natural',
    choices: ['formal', 'casual', 'technical', 'natural']
  })
  .option('dry-run', {
    describe: 'Ê∏¨Ë©¶Ê®°ÂºèÔºöÂÉÖÂàÜÊûêÊ™îÊ°àÔºå‰∏çÈÄ≤Ë°åÁøªË≠Ø',
    type: 'boolean',
    default: false
  })
  .option('retry', {
    describe: 'ÁøªË≠ØÂ§±ÊïóÊôÇÁöÑÈáçË©¶Ê¨°Êï∏',
    type: 'number',
    default: 3
  })
  .option('delay', {
    describe: 'Ë´ãÊ±ÇÈñìÈöîÊôÇÈñìÔºàÊØ´ÁßíÔºâ',
    type: 'number',
    default: 1000
  })
  .help()
  .argv;

// Ê™¢Êü• API Key
function checkApiKey() {
  const apiKey = process.env.MISTRAL_API_KEY;
  if (!apiKey) {
    console.error('‚ùå ÈåØË™§ÔºöË´ãË®≠ÂÆö MISTRAL_API_KEY Áí∞Â¢ÉËÆäÊï∏');
    console.log('\nË®≠ÂÆöÊñπÂºèÔºö');
    console.log('Windows (PowerShell): $env:MISTRAL_API_KEY = "your-api-key-here"');
    console.log('Windows (Command Prompt): set MISTRAL_API_KEY=your-api-key-here');
    console.log('macOS/Linux: export MISTRAL_API_KEY="your-api-key-here"');
    console.log('\nÂèñÂæó API KeyÔºö');
    console.log('1. ÂâçÂæÄ https://console.mistral.ai/');
    console.log('2. Ë®ªÂÜäÊàñÁôªÂÖ•Â∏≥Êà∂');
    console.log('3. Âª∫Á´ãÊñ∞ÁöÑ API Key');
    process.exit(1);
  }
  return apiKey;
}

// È©óË≠âÊ™îÊ°àÊ†ºÂºè
function validateFileFormat(filePath) {
  const extension = path.extname(filePath).toLowerCase();
  if (!SUPPORTED_EXTENSIONS.includes(extension)) {
    console.error(`‚ùå ‰∏çÊîØÊè¥ÁöÑÊ™îÊ°àÊ†ºÂºè: ${extension}`);
    console.log(`ÊîØÊè¥ÁöÑÊ†ºÂºè: ${SUPPORTED_EXTENSIONS.join(', ')}`);
    process.exit(1);
  }
  return extension;
}

// Ëß£Êûê SRT Ê™îÊ°à
function parseSRT(content) {
  const blocks = content.trim().split(/\n\s*\n/);
  const subtitles = [];
  
  blocks.forEach((block, index) => {
    const lines = block.trim().split('\n');
    if (lines.length >= 3) {
      const id = parseInt(lines[0]) || index + 1;
      const timeRange = lines[1];
      const text = lines.slice(2).join('\n');
      
      // È©óË≠âÊôÇÈñìÊ†ºÂºè
      if (timeRange.includes('-->')) {
        subtitles.push({
          id,
          timeRange,
          text: text.trim(),
          originalText: text.trim()
        });
      }
    }
  });
  
  return subtitles;
}

// Ëß£Êûê WebVTT Ê™îÊ°à
function parseWebVTT(content) {
  const subtitles = [];
  const lines = content.split('\n');
  let currentSubtitle = null;
  let id = 1;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Ë∑≥ÈÅé WEBVTT Ê®ôÈ†≠ÂíåÁ©∫Ë°å
    if (line === 'WEBVTT' || line === '' || line.startsWith('NOTE') || line.startsWith('STYLE')) {
      continue;
    }
    
    // Ê™¢Êü•ÊòØÂê¶ÁÇ∫ÊôÇÈñìËª∏Ê†ºÂºè
    if (line.includes('-->')) {
      currentSubtitle = {
        id: id++,
        timeRange: convertWebVTTTimeToSRT(line),
        text: '',
        originalText: ''
      };
      
      // Êî∂ÈõÜÂ≠óÂπïÊñáÂ≠ó
      let j = i + 1;
      const textLines = [];
      while (j < lines.length && lines[j].trim() !== '' && !lines[j].includes('-->')) {
        const textLine = lines[j].trim();
        if (textLine) {
          // ÁßªÈô§ WebVTT Ê†ºÂºèÊ®ôÁ±§
          const cleanText = textLine.replace(/<[^>]*>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
          textLines.push(cleanText);
        }
        j++;
      }
      
      if (textLines.length > 0) {
        currentSubtitle.text = textLines.join('\n');
        currentSubtitle.originalText = currentSubtitle.text;
        subtitles.push(currentSubtitle);
      }
      
      i = j - 1;
    }
  }
  
  return subtitles;
}

// Ëß£Êûê ASS Ê™îÊ°à
function parseASS(content) {
  const subtitles = [];
  const lines = content.split('\n');
  let inEventsSection = false;
  let formatLine = '';
  let id = 1;
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    
    if (trimmedLine === '[Events]') {
      inEventsSection = true;
      continue;
    }
    
    if (trimmedLine.startsWith('[') && trimmedLine !== '[Events]') {
      inEventsSection = false;
      continue;
    }
    
    if (inEventsSection) {
      if (trimmedLine.startsWith('Format:')) {
        formatLine = trimmedLine;
      } else if (trimmedLine.startsWith('Dialogue:')) {
        const subtitle = parseASSDialogue(trimmedLine, formatLine, id++);
        if (subtitle) {
          subtitles.push(subtitle);
        }
      }
    }
  }
  
  return subtitles;
}

// Ëß£Êûê ASS Â∞çË©±Ë°å
function parseASSDialogue(dialogueLine, formatLine, id) {
  const formatFields = formatLine.replace('Format:', '').split(',').map(f => f.trim());
  const dialogueFields = dialogueLine.replace('Dialogue:', '').split(',');
  
  const startIndex = formatFields.indexOf('Start');
  const endIndex = formatFields.indexOf('End');
  const textIndex = formatFields.indexOf('Text');
  
  if (startIndex === -1 || endIndex === -1 || textIndex === -1) {
    return null;
  }
  
  const startTime = convertASSTimeToSRT(dialogueFields[startIndex]);
  const endTime = convertASSTimeToSRT(dialogueFields[endIndex]);
  const text = dialogueFields.slice(textIndex).join(',').replace(/\\N/g, '\n').replace(/\{[^}]*\}/g, '');
  
  return {
    id,
    timeRange: `${startTime} --> ${endTime}`,
    text: text.trim(),
    originalText: text.trim()
  };
}

// Ëß£Êûê Markdown Ê™îÊ°à
function parseMarkdown(content) {
  const lines = content.split('\n');
  const subtitles = [];
  let id = 1;
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (trimmedLine && !trimmedLine.startsWith('#') && !trimmedLine.startsWith('```')) {
      subtitles.push({
        id: id++,
        timeRange: '00:00:00,000 --> 00:00:01,000', // È†êË®≠ÊôÇÈñì
        text: trimmedLine,
        originalText: trimmedLine
      });
    }
  }
  
  return subtitles;
}

// ËΩâÊèõÊôÇÈñìÊ†ºÂºè
function convertWebVTTTimeToSRT(webvttTime) {
  return webvttTime.replace(/\./g, ',');
}

function convertSRTTimeToWebVTT(srtTime) {
  return srtTime.replace(/,/g, '.');
}

function convertASSTimeToSRT(assTime) {
  // ASS ÊôÇÈñìÊ†ºÂºè: 0:00:00.00
  // SRT ÊôÇÈñìÊ†ºÂºè: 00:00:00,000
  const parts = assTime.split(':');
  if (parts.length === 3) {
    const hours = parts[0].padStart(2, '0');
    const minutes = parts[1].padStart(2, '0');
    const seconds = parts[2].replace('.', ',');
    // Ë£úÈΩäÊØ´Áßí‰ΩçÊï∏
    const [sec, ms] = seconds.split(',');
    const milliseconds = (ms || '0').padEnd(3, '0');
    return `${hours}:${minutes}:${sec.padStart(2, '0')},${milliseconds}`;
  }
  return assTime;
}

// Ëá™ÂãïÊ™¢Ê∏¨Ê™îÊ°àÊ†ºÂºè‰∏¶Ëß£Êûê
function parseSubtitleFile(content, filePath) {
  const extension = path.extname(filePath).toLowerCase();
  
  switch (extension) {
    case '.vtt':
      console.log('üìù Ê™¢Ê∏¨Âà∞ WebVTT Ê†ºÂºè');
      return parseWebVTT(content);
    case '.srt':
      console.log('üìù Ê™¢Ê∏¨Âà∞ SRT Ê†ºÂºè');
      return parseSRT(content);
    case '.ass':
      console.log('üìù Ê™¢Ê∏¨Âà∞ ASS Ê†ºÂºè');
      return parseASS(content);
    case '.md':
      console.log('üìù Ê™¢Ê∏¨Âà∞ Markdown Ê†ºÂºè');
      return parseMarkdown(content);
    default:
      // ÂòóË©¶Ê†πÊìöÂÖßÂÆπËá™ÂãïÊ™¢Ê∏¨
      if (content.includes('WEBVTT')) {
        console.log('üìù Ëá™ÂãïÊ™¢Ê∏¨ÁÇ∫ WebVTT Ê†ºÂºè');
        return parseWebVTT(content);
      } else if (content.includes('[Events]')) {
        console.log('üìù Ëá™ÂãïÊ™¢Ê∏¨ÁÇ∫ ASS Ê†ºÂºè');
        return parseASS(content);
      } else {
        console.log('üìù ÂÅáË®≠ÁÇ∫ SRT Ê†ºÂºè');
        return parseSRT(content);
      }
  }
}

// ÁîüÊàêËº∏Âá∫Ê™îÊ°à
function generateSRT(subtitles) {
  return subtitles.map(subtitle => 
    `${subtitle.id}\n${subtitle.timeRange}\n${subtitle.text}\n`
  ).join('\n');
}

function generateWebVTT(subtitles) {
  let content = 'WEBVTT\n\n';
  
  subtitles.forEach(subtitle => {
    content += `${convertSRTTimeToWebVTT(subtitle.timeRange)}\n`;
    content += `${subtitle.text}\n\n`;
  });
  
  return content;
}

function generateASS(subtitles) {
  let content = `[Script Info]
Title: Translated Subtitles
ScriptType: v4.00+

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  subtitles.forEach(subtitle => {
    const [startTime, endTime] = subtitle.timeRange.split(' --> ');
    const assStartTime = convertSRTTimeToASS(startTime);
    const assEndTime = convertSRTTimeToASS(endTime);
    const text = subtitle.text.replace(/\n/g, '\\N');
    
    content += `Dialogue: 0,${assStartTime},${assEndTime},Default,,0,0,0,,${text}\n`;
  });
  
  return content;
}

function convertSRTTimeToASS(srtTime) {
  // SRT: 00:00:00,000 -> ASS: 0:00:00.00
  const [time, ms] = srtTime.split(',');
  const [hours, minutes, seconds] = time.split(':');
  const centiseconds = Math.floor(parseInt(ms) / 10);
  return `${parseInt(hours)}:${minutes}:${seconds}.${centiseconds.toString().padStart(2, '0')}`;
}

function generateMarkdown(subtitles) {
  return subtitles.map(subtitle => subtitle.text).join('\n\n');
}

// Ê†πÊìöÊ™îÊ°àÊ†ºÂºèÁîüÊàêÂÖßÂÆπ
function generateSubtitleFile(subtitles, filePath) {
  const extension = path.extname(filePath).toLowerCase();
  
  switch (extension) {
    case '.vtt':
      return generateWebVTT(subtitles);
    case '.ass':
      return generateASS(subtitles);
    case '.md':
      return generateMarkdown(subtitles);
    default:
      return generateSRT(subtitles);
  }
}

// Ëá™Âãï‰øÆÂæ©Â≠óÂπïÁ∑®Ëôü
function autoFixSubtitles(subtitles) {
  console.log('üîß Ê≠£Âú®‰øÆÂæ©Â≠óÂπïÁ∑®Ëôü...');
  
  const fixed = subtitles.map((subtitle, index) => ({
    ...subtitle,
    id: index + 1
  }));
  
  // Ê™¢Êü•ÊôÇÈñìËª∏È†ÜÂ∫è
  let timeIssues = 0;
  for (let i = 1; i < fixed.length; i++) {
    const prevEnd = getTimeStamp(fixed[i-1].timeRange.split(' --> ')[1]);
    const currStart = getTimeStamp(fixed[i].timeRange.split(' --> ')[0]);
    
    if (currStart < prevEnd) {
      timeIssues++;
    }
  }
  
  if (timeIssues > 0) {
    console.warn(`‚ö†Ô∏è  ÁôºÁèæ ${timeIssues} ÂÄãÊôÇÈñìËª∏ÈáçÁñäÂïèÈ°å`);
  }
  
  console.log(`‚úÖ Â≠óÂπïÁ∑®ËôüÂ∑≤‰øÆÂæ© (${fixed.length} Ê¢ùÂ≠óÂπï)`);
  return fixed;
}

// ËΩâÊèõÊôÇÈñìÁÇ∫ÊØ´Áßí
function getTimeStamp(timeStr) {
  const [time, ms] = timeStr.split(',');
  const [hours, minutes, seconds] = time.split(':').map(Number);
  return hours * 3600000 + minutes * 60000 + seconds * 1000 + Number(ms);
}

// ÁîüÊàêÂÖßÂÆπÊëòË¶Å
async function generateContentSummary(subtitles, apiKey, model) {
  console.log('üß† Ê≠£Âú®ÂàÜÊûêÂÖßÂÆπÁâπÂæµ...');
  
  // ÂèñÊ®£Â≠óÂπïÈÄ≤Ë°åÂàÜÊûê
  const sampleSize = Math.min(50, subtitles.length);
  const sampleText = subtitles.slice(0, sampleSize).map(s => s.text).join('\n');
  
  // Áµ±Ë®àË≥áË®ä
  const stats = {
    totalSubtitles: subtitles.length,
    avgLength: Math.round(subtitles.reduce((sum, s) => sum + s.text.length, 0) / subtitles.length),
    maxLength: Math.max(...subtitles.map(s => s.text.length)),
    minLength: Math.min(...subtitles.map(s => s.text.length))
  };
  
  const styleMap = {
    'formal': 'Ê≠£Âºè„ÄÅÂ∞àÊ•≠',
    'casual': 'ËºïÈ¨Ü„ÄÅÂè£Ë™ûÂåñ',
    'technical': 'ÊäÄË°ìÊÄß„ÄÅÊ∫ñÁ¢∫',
    'natural': 'Ëá™ÁÑ∂„ÄÅÊµÅÊö¢'
  };
  
  const prompt = `Ë´ãÂàÜÊûê‰ª•‰∏ã${argv.fromLang}Â≠óÂπïÂÖßÂÆπ‰∏¶ÁîüÊàêÁøªË≠ØÊåáÂ∞éÊëòË¶ÅÔºö

Áµ±Ë®àË≥áË®äÔºö
- Á∏ΩÂ≠óÂπïÊï∏Ôºö${stats.totalSubtitles}
- Âπ≥ÂùáÈï∑Â∫¶Ôºö${stats.avgLength} Â≠óÂÖÉ
- ÁøªË≠ØÈ¢®Ê†ºÔºö${styleMap[argv.style]}
- ÁõÆÊ®ôË™ûË®ÄÔºö${argv.toLang}

Â≠óÂπïÁØÑ‰æãÔºö
${sampleText}

Ë´ãÊèê‰æõÁ∞°Ë¶ÅÂàÜÊûêÔºåÂåÖÊã¨Ôºö
1. ÂÖßÂÆπÈ°ûÂûãÂíå‰∏ªÈ°å
2. Ë™ûË®ÄÁâπËâ≤ÂíåÂ∞àÊ•≠Ë°ìË™û
3. ÁøªË≠ØÂª∫Ë≠∞ÂíåÊ≥®ÊÑè‰∫ãÈ†Ö

Ë´ãÁî®${argv.toLang}ÂõûÁ≠îÔºå‰∏¶‰øùÊåÅÁ∞°ÊΩî (200Â≠ó‰ª•ÂÖß)„ÄÇ`;

  try {
    const response = await axios.post(MISTRAL_API_URL, {
      model: model,
      messages: [
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 500
    }, {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      }
    });

    const summary = response.data.choices[0].message.content;
    console.log('üìã ÂÖßÂÆπÂàÜÊûêÁµêÊûúÔºö');
    console.log(summary);
    console.log('');
    
    return summary;
  } catch (error) {
    console.warn('‚ö†Ô∏è  ÁÑ°Ê≥ïÁîüÊàêÂÖßÂÆπÊëòË¶ÅÔºåÂ∞á‰ΩøÁî®È†êË®≠ÁøªË≠ØÁ≠ñÁï•');
    return `‰∏ÄËà¨${argv.fromLang}ÂÖßÂÆπÔºåË´ãÁøªË≠ØÊàê${argv.toLang}Ôºå‰øùÊåÅ${styleMap[argv.style]}È¢®Ê†º„ÄÇ`;
  }
}

// ÁøªË≠ØÂ≠óÂπïÊâπÊ¨°
async function translateBatch(subtitles, context, apiKey, model, retryCount = 0) {
  const subtitleTexts = subtitles.map((s, index) => 
    `${index + 1}. ${s.text}`
  ).join('\n');

  const styleInstructions = {
    'formal': '‰ΩøÁî®Ê≠£Âºè„ÄÅÊõ∏Èù¢Ë™ûÈ´î',
    'casual': '‰ΩøÁî®Âè£Ë™ûÂåñ„ÄÅË¶™ÂàáÁöÑË°®ÈÅî',
    'technical': '‰øùÊåÅÊäÄË°ìË°ìË™ûÊ∫ñÁ¢∫ÊÄß',
    'natural': '‰ΩøÁî®Ëá™ÁÑ∂ÊµÅÊö¢ÁöÑË°®ÈÅî'
  };

  const prompt = `Ë´ãÂ∞á‰ª•‰∏ã${argv.fromLang}Â≠óÂπïÁøªË≠ØÊàê${argv.toLang}„ÄÇ

ÂÖßÂÆπËÉåÊôØÔºö
${context}

ÁøªË≠ØË¶ÅÊ±ÇÔºö
1. ${styleInstructions[argv.style]}
2. ‰øùÊåÅÂéüÊÑèÂíåË™ûË™ø
3. ËÄÉÊÖÆÊñáÂåñËÉåÊôØÂ∑ÆÁï∞
4. ‰øùÊåÅÂ≠óÂπïÈï∑Â∫¶ÈÅ©‰∏≠
5. ÂøÖÈ†àÂö¥Ê†ºÊåâÁÖß JSON Ê†ºÂºèÂõûÊáâ

${argv.fromLang}Â≠óÂπïÔºö
${subtitleTexts}

Ë´ãÂõûÁ≠î JSON Ê†ºÂºèÔºö
{
  "translations": [
    "ÁøªË≠ØÂæåÁöÑÁ¨¨1Âè•",
    "ÁøªË≠ØÂæåÁöÑÁ¨¨2Âè•",
    ...
  ]
}`;

  try {
    const response = await axios.post(MISTRAL_API_URL, {
      model: model,
      messages: [
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 4000
    }, {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      }
    });

    const content = response.data.choices[0].message.content;
    
    try {
      // ÂòóË©¶Ëß£Êûê JSON
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        if (parsed.translations && Array.isArray(parsed.translations)) {
          if (parsed.translations.length !== subtitles.length) {
            throw new Error(`ÁøªË≠ØÊï∏Èáè‰∏çÁ¨¶ÔºöÊúüÊúõ ${subtitles.length}ÔºåÂæóÂà∞ ${parsed.translations.length}`);
          }
          return parsed.translations;
        }
      }
      
      // Â¶ÇÊûú JSON Ëß£ÊûêÂ§±ÊïóÔºåÂòóË©¶ÊâãÂãïÊèêÂèñ
      const lines = content.split('\n').filter(line => line.trim());
      const translations = [];
      
      for (const line of lines) {
        const match = line.match(/^\d+\.\s*(.+)/) || line.match(/"(.+)"/);
        if (match) {
          translations.push(match[1]);
        }
      }
      
      if (translations.length === subtitles.length) {
        return translations;
      }
      
      throw new Error(`ÊâãÂãïËß£ÊûêÂ§±ÊïóÔºöÊúüÊúõ ${subtitles.length}ÔºåÂæóÂà∞ ${translations.length}`);
      
    } catch (parseError) {
      console.error('JSON Ëß£ÊûêÈåØË™§:', parseError.message);
      throw new Error('ÁøªË≠ØÂõûÊáâÊ†ºÂºèÈåØË™§');
    }
    
  } catch (error) {
    if (retryCount < argv.retry) {
      console.warn(`‚ö†Ô∏è  ÊâπÊ¨°ÁøªË≠ØÂ§±ÊïóÔºåÊ≠£Âú®ÈáçË©¶ (${retryCount + 1}/${argv.retry})...`);
      await new Promise(resolve => setTimeout(resolve, argv.delay * (retryCount + 1)));
      return translateBatch(subtitles, context, apiKey, model, retryCount + 1);
    }
    
    if (error.response) {
      console.error('API ÈåØË™§:', error.response.status, error.response.data);
    } else {
      console.error('Á∂≤Ë∑ØÈåØË™§:', error.message);
    }
    throw error;
  }
}

// ÈÄ≤Â∫¶ËøΩËπ§
function createProgressTracker(total) {
  let completed = 0;
  let failed = 0;
  
  return {
    update: (success = true) => {
      if (success) {
        completed++;
      } else {
        failed++;
      }
      
      const progress = Math.round(((completed + failed) / total) * 100);
      const bar = '‚ñà'.repeat(Math.floor(progress / 5)) + '‚ñë'.repeat(20 - Math.floor(progress / 5));
      
      process.stdout.write(`\rüîÑ ÁøªË≠ØÈÄ≤Â∫¶: [${bar}] ${progress}% (${completed}/${total})`);
      
      if (failed > 0) {
        process.stdout.write(` ‚ùå ${failed}`);
      }
    },
    
    finish: () => {
      process.stdout.write('\n');
      if (failed > 0) {
        console.log(`‚ö†Ô∏è  ${failed} ÂÄãÊâπÊ¨°ÁøªË≠ØÂ§±Êïó`);
      }
      console.log(`‚úÖ ÁøªË≠ØÂÆåÊàêÔºö${completed}/${total} ÂÄãÊâπÊ¨°ÊàêÂäü`);
    }
  };
}

// Êñá‰ª∂Áµ±Ë®à
function generateStatistics(originalSubtitles, translatedSubtitles) {
  const originalChars = originalSubtitles.reduce((sum, s) => sum + s.text.length, 0);
  const translatedChars = translatedSubtitles.reduce((sum, s) => sum + s.text.length, 0);
  
  const avgOriginalLength = Math.round(originalChars / originalSubtitles.length);
  const avgTranslatedLength = Math.round(translatedChars / translatedSubtitles.length);
  
  return {
    subtitleCount: originalSubtitles.length,
    originalChars,
    translatedChars,
    expansionRatio: Math.round((translatedChars / originalChars) * 100) / 100,
    avgOriginalLength,
    avgTranslatedLength
  };
}

// ‰∏ªË¶ÅÂü∑Ë°åÂáΩÊï∏
async function main() {
  try {
    console.log('üöÄ Mistral AI Â≠óÂπïÁøªË≠ØÂ∑•ÂÖ∑ v2.0 ÂïüÂãï‰∏≠...');
    
    // Ê™¢Êü• API Key
    const apiKey = checkApiKey();
    
    // Ê™¢Êü•Ëº∏ÂÖ•Ê™îÊ°à
    const inputFile = argv.input;
    if (!fs.existsSync(inputFile)) {
      console.error(`‚ùå Êâæ‰∏çÂà∞Ëº∏ÂÖ•Ê™îÊ°à: ${inputFile}`);
      process.exit(1);
    }
    
    // È©óË≠âÊ™îÊ°àÊ†ºÂºè
    const inputExtension = validateFileFormat(inputFile);
    
    // Ë®≠ÂÆöËº∏Âá∫Ê™îÊ°à
    let outputFile = argv.output;
    if (!outputFile) {
      const inputName = path.basename(inputFile, inputExtension);
      const inputDir = path.dirname(inputFile);
      outputFile = path.join(inputDir, `${inputName}.zh${inputExtension}`);
    }
    
    console.log(`üìÇ Ëº∏ÂÖ•Ê™îÊ°à: ${inputFile}`);
    console.log(`üìÇ Ëº∏Âá∫Ê™îÊ°à: ${outputFile}`);
    console.log(`ü§ñ ‰ΩøÁî®Ê®°Âûã: ${argv.model}`);
    console.log(`üåê ÁøªË≠Ø: ${argv.fromLang} ‚Üí ${argv.toLang}`);
    console.log(`üé® È¢®Ê†º: ${argv.style}`);
    console.log(`‚ö° ‰∏¶ÁôºÊï∏: ${argv.concurrency}`);
    console.log(`üì¶ ÊâπÊ¨°Â§ßÂ∞è: ${argv.batchSize}`);
    
    // ËÆÄÂèñ‰∏¶Ëß£ÊûêÂ≠óÂπïÊ™îÊ°à
    console.log('üìñ ËÆÄÂèñÂ≠óÂπïÊ™îÊ°à...');
    const content = fs.readFileSync(inputFile, 'utf8');
    let subtitles = parseSubtitleFile(content, inputFile);
    
    if (subtitles.length === 0) {
      console.error('‚ùå ÁÑ°Ê≥ïËß£ÊûêÂ≠óÂπïÊ™îÊ°àÊàñÊ™îÊ°àÁÇ∫Á©∫');
      process.exit(1);
    }
    
    console.log(`üìä ÊâæÂà∞ ${subtitles.length} Ê¢ùÂ≠óÂπï`);
    
    // Ëá™Âãï‰øÆÂæ©Á∑®ËôüÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
    if (argv.autofix) {
      subtitles = autoFixSubtitles(subtitles);
    }
    
    // Ê∏¨Ë©¶Ê®°Âºè
    if (argv.dryRun) {
      console.log('üß™ Ê∏¨Ë©¶Ê®°ÂºèÔºöÂÉÖÂàÜÊûêÊ™îÊ°àÁµêÊßã');
      const stats = generateStatistics(subtitles, subtitles);
      console.log(`üìà Áµ±Ë®àË≥áË®äÔºö`);
      console.log(`   Â≠óÂπïÊï∏Èáè: ${stats.subtitleCount}`);
      console.log(`   Á∏ΩÂ≠óÂÖÉÊï∏: ${stats.originalChars}`);
      console.log(`   Âπ≥ÂùáÈï∑Â∫¶: ${stats.avgOriginalLength} Â≠óÂÖÉ`);
      console.log('‚úÖ ÂàÜÊûêÂÆåÊàêÔºåÊú™ÈÄ≤Ë°åÁøªË≠Ø');
      return;
    }
    
    // ÁîüÊàêÂÖßÂÆπÊëòË¶Å
    console.log('üß† ÂàÜÊûêÂÖßÂÆπ‰∏¶ÁîüÊàêÁøªË≠ØËÉåÊôØ...');
    const context = await generateContentSummary(subtitles, apiKey, argv.model);
    
    // ÂàÜÊâπËôïÁêÜÂ≠óÂπï
    const batchSize = argv.batchSize;
    const batches = [];
    for (let i = 0; i < subtitles.length; i += batchSize) {
      batches.push(subtitles.slice(i, i + batchSize));
    }
    
    console.log(`üîÑ ÈñãÂßãÁøªË≠Ø ${batches.length} ÂÄãÊâπÊ¨°...`);
    
    // ÂàùÂßãÂåñÈÄ≤Â∫¶ËøΩËπ§
    const progress = createProgressTracker(batches.length);
    const translatedSubtitles = [];
    
    // ‰ΩøÁî® Promise Pool ÊéßÂà∂‰∏¶ÁôºÊï∏Èáè
    const { results, errors } = await PromisePool
      .withConcurrency(argv.concurrency)
      .for(batches)
      .process(async (batch, index) => {
        try {
          // Ê∑ªÂä†Âª∂ÈÅ≤ÈÅøÂÖç API ÈôêÂà∂
          if (index > 0) {
            await new Promise(resolve => setTimeout(resolve, argv.delay));
          }
          
          const translations = await translateBatch(batch, context, apiKey, argv.model);
          
          const translatedBatch = batch.map((subtitle, i) => ({
            ...subtitle,
            text: translations[i] || subtitle.text
          }));
          
          progress.update(true);
          return { index, batch: translatedBatch };
        } catch (error) {
          progress.update(false);
          console.error(`\n‚ùå ÊâπÊ¨° ${index + 1} ÁøªË≠ØÂ§±Êïó:`, error.message);
          
          // ËøîÂõûÂéüÂßãÂÖßÂÆπ‰ΩúÁÇ∫ÂÇôÁî®
          return { index, batch: batch };
        }
      });
    
    progress.finish();
    
    // ÈáçÊñ∞ÁµÑÂêàÁøªË≠ØÁµêÊûú
    const sortedResults = results.sort((a, b) => a.index - b.index);
    sortedResults.forEach(result => {
      translatedSubtitles.push(...result.batch);
    });
    
    // È©óË≠âÁøªË≠ØÁµêÊûú
    if (translatedSubtitles.length !== subtitles.length) {
      console.error('‚ùå ÁøªË≠ØÊï∏ÈáèËàáÂéüÂßãÂ≠óÂπïÊï∏Èáè‰∏çÁ¨¶');
      console.error(`ÂéüÂßã: ${subtitles.length}, ÁøªË≠ØÂæå: ${translatedSubtitles.length}`);
      process.exit(1);
    }
    
    // ÁîüÊàêÁµ±Ë®àË≥áË®ä
    const stats = generateStatistics(subtitles, translatedSubtitles);
    
    // ÂÑ≤Â≠òÁøªË≠ØÁµêÊûú
    console.log('üíæ ÂÑ≤Â≠òÁøªË≠ØÁµêÊûú...');
    const translatedContent = generateSubtitleFile(translatedSubtitles, outputFile);
    
    // Á¢∫‰øùËº∏Âá∫ÁõÆÈåÑÂ≠òÂú®
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    fs.writeFileSync(outputFile, translatedContent, 'utf8');
    
    // Ëº∏Âá∫ÂÆåÊàêË≥áË®ä
    console.log('üéâ ÁøªË≠ØÂÆåÊàêÔºÅ');
    console.log(`üìÅ ÁøªË≠ØÊ™îÊ°àÂ∑≤ÂÑ≤Â≠òËá≥: ${outputFile}`);
    console.log('');
    console.log('üìä ÁøªË≠ØÁµ±Ë®àÔºö');
    console.log(`   Â≠óÂπïÊï∏Èáè: ${stats.subtitleCount}`);
    console.log(`   ÂéüÊñáÂ≠óÂÖÉ: ${stats.originalChars.toLocaleString()}`);
    console.log(`   Ë≠ØÊñáÂ≠óÂÖÉ: ${stats.translatedChars.toLocaleString()}`);
    console.log(`   Êì¥Â±ïÊØî‰æã: ${stats.expansionRatio}x`);
    console.log(`   Âπ≥ÂùáÈï∑Â∫¶: ${stats.avgOriginalLength} ‚Üí ${stats.avgTranslatedLength} Â≠óÂÖÉ`);
    
    if (errors.length > 0) {
      console.log('');
      console.warn(`‚ö†Ô∏è  ${errors.length} ÂÄãÊâπÊ¨°ËôïÁêÜÊôÇÁôºÁîüÈåØË™§ÔºåÂ∑≤‰ΩøÁî®ÂéüÊñáÊõø‰ª£`);
    }
    
    // ÁîüÊàêÁøªË≠ØÂ†±Âëä
    if (argv.report) {
      await generateTranslationReport(subtitles, translatedSubtitles, stats, outputFile);
    }
    
  } catch (error) {
    console.error('‚ùå Á®ãÂºèÂü∑Ë°åÈåØË™§:', error.message);
    if (error.stack && argv.debug) {
      console.error('Ë©≥Á¥∞ÈåØË™§Ôºö', error.stack);
    }
    process.exit(1);
  }
}

// ÁîüÊàêÁøªË≠ØÂ†±Âëä
async function generateTranslationReport(original, translated, stats, outputFile) {
  const reportFile = outputFile.replace(path.extname(outputFile), '.report.md');
  
  let report = `# ÁøªË≠ØÂ†±Âëä

## Âü∫Êú¨Ë≥áË®ä
- ÁøªË≠ØÊôÇÈñì: ${new Date().toLocaleString('zh-TW')}
- ‰æÜÊ∫êË™ûË®Ä: ${argv.fromLang}
- ÁõÆÊ®ôË™ûË®Ä: ${argv.toLang}
- ÁøªË≠ØÈ¢®Ê†º: ${argv.style}
- ‰ΩøÁî®Ê®°Âûã: ${argv.model}

## Áµ±Ë®àË≥áË®ä
- Â≠óÂπïÊï∏Èáè: ${stats.subtitleCount}
- ÂéüÊñáÂ≠óÂÖÉÊï∏: ${stats.originalChars.toLocaleString()}
- Ë≠ØÊñáÂ≠óÂÖÉÊï∏: ${stats.translatedChars.toLocaleString()}
- ÊñáÊú¨Êì¥Â±ïÊØî‰æã: ${stats.expansionRatio}x
- Âπ≥ÂùáÂ≠óÂπïÈï∑Â∫¶: ${stats.avgOriginalLength} ‚Üí ${stats.avgTranslatedLength} Â≠óÂÖÉ

## ÁøªË≠ØÊ®£Êú¨ (Ââç10Ê¢ù)
`;

  for (let i = 0; i < Math.min(10, original.length); i++) {
    report += `\n### ${i + 1}. ${original[i].timeRange}\n`;
    report += `**ÂéüÊñá:** ${original[i].originalText}\n\n`;
    report += `**Ë≠ØÊñá:** ${translated[i].text}\n\n`;
  }
  
  fs.writeFileSync(reportFile, report, 'utf8');
  console.log(`üìã ÁøªË≠ØÂ†±ÂëäÂ∑≤ÂÑ≤Â≠òËá≥: ${reportFile}`);
}

// ÈåØË™§ËôïÁêÜÂíåÊ∏ÖÁêÜ
process.on('SIGINT', () => {
  console.log('\nüëã Á®ãÂºèË¢´‰∏≠Êñ∑ÔºåÊ≠£Âú®Ê∏ÖÁêÜ...');
  process.exit(0);
});

process.on('uncaughtException', (error) => {
  console.error('‚ùå Êú™ÊçïÁç≤ÁöÑÁï∞Â∏∏:', error.message);
  if (argv.debug) {
    console.error(error.stack);
  }
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Êú™ËôïÁêÜÁöÑ Promise ÊãíÁµï:', reason);
  if (argv.debug) {
    console.error('Promise:', promise);
  }
  process.exit(1);
});

// Âü∑Ë°åÁ®ãÂºè
if (require.main === module) {
  main();
}

// Â∞éÂá∫Ê®°ÁµÑÂáΩÊï∏‰æõÊ∏¨Ë©¶‰ΩøÁî®
module.exports = {
  parseSRT,
  parseWebVTT,
  parseASS,
  parseMarkdown,
  parseSubtitleFile,
  generateSRT,
  generateWebVTT,
  generateASS,
  generateMarkdown,
  generateSubtitleFile,
  autoFixSubtitles,
  translateBatch,
  generateContentSummary,
  generateStatistics,
  validateFileFormat,
  convertWebVTTTimeToSRT,
  convertSRTTimeToWebVTT,
  convertASSTimeToSRT,
  convertSRTTimeToASS
};